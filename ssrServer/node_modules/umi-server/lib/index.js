"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _react() {
  const data = _interopRequireDefault(require("react"));

  _react = function _react() {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function _path() {
    return data;
  };

  return data;
}

var _compose = _interopRequireDefault(require("./compose"));

var _debug = _interopRequireDefault(require("./debug"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const server = config => {
  const root = config.root,
        _config$manifest = config.manifest,
        manifest = _config$manifest === void 0 ? (0, _path().join)(root, 'ssr-client-mainifest.json') : _config$manifest,
        _config$filename = config.filename,
        filename = _config$filename === void 0 ? (0, _path().join)(root, 'umi.server') : _config$filename,
        _config$staticMarkup = config.staticMarkup,
        staticMarkup = _config$staticMarkup === void 0 ? false : _config$staticMarkup,
        _config$polyfill = config.polyfill,
        polyfill = _config$polyfill === void 0 ? false : _config$polyfill,
        _config$postProcessHt = config.postProcessHtml,
        postProcessHtml = _config$postProcessHt === void 0 ? $ => $ : _config$postProcessHt,
        customRender = config.customRender,
        _config$dev = config.dev,
        dev = _config$dev === void 0 ? process.env.NODE_ENV === 'development' : _config$dev;
  const polyfillHost = typeof polyfill === 'object' && polyfill.host ? polyfill.host : 'http://localhost';
  const nodePolyfill = (0, _utils.nodePolyfillDecorator)(!!polyfill, polyfillHost);

  const serverRender = require(filename);

  const manifestFile = require(manifest);

  if (dev) {
    // remove module cache when in dev mode
    delete require.cache[require.resolve(filename)];
    delete require.cache[require.resolve(manifest)];
  }

  const ReactDOMServer = serverRender.ReactDOMServer;
  (0, _debug.default)('manifestFile', _debug.default);
  return (
    /*#__PURE__*/
    function () {
      var _ref = _asyncToGenerator(function* (ctx, renderOpts = {}) {
        const url = ctx.req.url; // polyfill pathname

        nodePolyfill(renderOpts, {
          url
        });
        const serverRenderRes = yield serverRender.default(ctx);
        const htmlElement = serverRenderRes.htmlElement,
              matchPath = serverRenderRes.matchPath,
              g_initialData = serverRenderRes.g_initialData; // if not found, return undefined

        if (!matchPath) {
          return {
            ssrHtml: undefined,
            matchPath: undefined,
            chunkMap: {
              js: [],
              css: []
            },
            g_initialData: {}
          };
        }

        const chunkMap = manifestFile[matchPath];
        const reactRender = ReactDOMServer[staticMarkup ? 'renderToStaticMarkup' : 'renderToString'];
        const renderString = typeof customRender === 'function' ? yield customRender(_objectSpread({}, serverRenderRes, {
          chunkMap
        })) : reactRender(htmlElement);
        const processHtmlHandlers = Array.isArray(postProcessHtml) ? postProcessHtml : [postProcessHtml];
        const composeRender = (0, _compose.default)(_utils.injectChunkMaps, // user define handler
        ...processHtmlHandlers);
        const ssrHtml = (0, _utils.filterRootContainer)(renderString, (layoutHtml, context) => {
          const $ = (0, _utils._getDocumentHandler)(layoutHtml);

          const handlerOpts = _objectSpread({}, context, {
            chunkMap
          }); // compose all layoutHtml handlers


          return composeRender($, handlerOpts).html();
        }); // enable render rootContainer
        // const ssrHtmlElement =

        return {
          ssrHtml,
          matchPath,
          chunkMap,
          g_initialData
        };
      });

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }()
  );
};

var _default = server;
exports.default = _default;