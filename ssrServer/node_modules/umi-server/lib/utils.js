"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nodePolyfillDecorator = exports.injectChunkMaps = exports._getDocumentHandler = exports.filterRootContainer = void 0;

function _react() {
  const data = _interopRequireDefault(require("react"));

  _react = function _react() {
    return data;
  };

  return data;
}

function _ssrPolyfill() {
  const data = _interopRequireDefault(require("ssr-polyfill"));

  _ssrPolyfill = function _ssrPolyfill() {
    return data;
  };

  return data;
}

function _isPlainObject() {
  const data = _interopRequireDefault(require("lodash/isPlainObject"));

  _isPlainObject = function _isPlainObject() {
    return data;
  };

  return data;
}

function _merge() {
  const data = _interopRequireDefault(require("lodash/merge"));

  _merge = function _merge() {
    return data;
  };

  return data;
}

function _url() {
  const data = require("url");

  _url = function _url() {
    return data;
  };

  return data;
}

function _cheerio() {
  const data = require("cheerio");

  _cheerio = function _cheerio() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * root html fragment string not parse by cheerio for better perfs
 * 1. <body>(.*)</body> => <body><!-- UMI_SERVER_TMP_PLACEHOLDER --></body>
 * 2. handlers => postProcessHtml html fragment
 * 3. <body><!-- UMI_SERVER_TMP_PLACEHOLDER -->...handler created</body>
 *    => <body>(.*)...handler created</body>
 *
 * @param html React server render origin html string
 * @param functor layout html functor for hanlders using cheerio
 */
const filterRootContainer = (html, functor) => {
  const bodyExp = /<body>([\s\S]*?)<\/body>/i;
  const placeholderExp = /<!\x2D\x2D UMI_SERVER_TMP_PLACEHOLDER \x2D\x2D>/g;
  const placeholder = '<body><!-- UMI_SERVER_TMP_PLACEHOLDER --></body>';
  const layout = html.replace(bodyExp, placeholder);
  const root = html.match(bodyExp) ? html.match(bodyExp)[1] : '';
  const matchPublicPath = root.match(/<script.*src="([^"]*)\/?umi\.(\w+\.)?js"[^>]*>/i);
  const publicPath = matchPublicPath ? matchPublicPath[1] : '/';
  const context = {
    publicPath
  };
  const layoutHtml = functor(layout, context);
  return layoutHtml.replace(placeholderExp, root);
};

exports.filterRootContainer = filterRootContainer;

const _getDocumentHandler = (html, option = {}) => {
  const docTypeHtml = /^<!DOCTYPE html>/.test(html) ? html : `<!DOCTYPE html>${html}`;
  return (0, _cheerio().load)(docTypeHtml, _objectSpread({
    decodeEntities: false,
    recognizeSelfClosing: true
  }, option));
};

exports._getDocumentHandler = _getDocumentHandler;

const injectChunkMaps = ($, args) => {
  const chunkMap = args.chunkMap,
        _args$publicPath = args.publicPath,
        publicPath = _args$publicPath === void 0 ? '/' : _args$publicPath;

  const _ref = chunkMap || {},
        _ref$js = _ref.js,
        js = _ref$js === void 0 ? [] : _ref$js,
        _ref$css = _ref.css,
        css = _ref$css === void 0 ? [] : _ref$css; // filter umi.css and umi.*.css, htmlMap have includes


  const styles = css.filter(style => !/^umi\.(\w+\.)?css$/g.test(style)) || [];
  styles.forEach(style => {
    if (style) {
      $('head').append(`<link rel="stylesheet" href="${publicPath}${style}" />`);
    }
  }); // filter umi.js and umi.*.js

  const scripts = js.filter(script => !/^umi([.\w]*)?\.js$/g.test(script)) || [];
  scripts.forEach(script => {
    if (script) {
      $('head').append(`<link rel="preload" href="${publicPath}${script}" as="script"/>`);
    }
  });
  return $;
};

exports.injectChunkMaps = injectChunkMaps;

const nodePolyfillDecorator = (enable = false, origin = 'http://localhost') => {
  const _parse = (0, _url().parse)(origin),
        defaultPathname = _parse.pathname; // @ts-ignore


  global.window = {};

  if (enable) {
    const mockWin = (0, _ssrPolyfill().default)({
      url: origin
    });
    const mountGlobal = ['document', 'location', 'navigator', 'Image', 'self'];
    mountGlobal.forEach(mount => {
      global[mount] = mockWin[mount];
    }); // @ts-ignore

    global.window = mockWin; // using window.document, window.location to mock document, location

    mountGlobal.forEach(mount => {
      global[mount] = mockWin[mount];
    }); // if use pathname to mock location.pathname

    return (renderOpts, context = {
      url: defaultPathname
    }) => {
      const url = context.url;
      const polyfill = renderOpts.polyfill,
            runInMockContext = renderOpts.runInMockContext;
      let nextOrigin = url;

      if (typeof polyfill === 'object' && polyfill.host) {
        nextOrigin = `${polyfill.host}${url}`;
      }

      const _parse2 = (0, _url().parse)(origin),
            protocol = _parse2.protocol,
            host = _parse2.host;

      const nextUrl = /^https?:\/\//.test(nextOrigin) ? nextOrigin : `${protocol}//${host}${url}`;
      const nextObj = (0, _url().parse)(nextUrl); // @ts-ignore

      Object.defineProperty(global.window, 'location', {
        writable: true,
        value: _objectSpread({
          // patch window.location.origin
          origin: `${nextObj.protocol}//${nextObj.hostname}${nextObj.port ? `:${nextObj.port}` : ''}`
        }, nextObj)
      }); // @ts-ignore

      global.location = _objectSpread({
        // patch location.origin
        origin: `${nextObj.protocol}//${nextObj.hostname}${nextObj.port ? `:${nextObj.port}` : ''}`
      }, nextObj);

      if (runInMockContext) {
        let mockContext;

        if ((0, _isPlainObject().default)(runInMockContext)) {
          mockContext = runInMockContext;
        }

        if (typeof runInMockContext === 'function') {
          mockContext = runInMockContext();
        } // @ts-ignore


        (0, _merge().default)(global.window, mockContext || {});
      }
    };
  }

  return () => {// noop
  };
};

exports.nodePolyfillDecorator = nodePolyfillDecorator;