import { load } from 'cheerio';
import * as React from 'react';
interface IDynamicChunkMap {
    js: string[];
    css: string[];
}
export interface IFilterContext {
    publicPath: string;
}
export interface IArgs extends Partial<IFilterContext> {
    chunkMap: IDynamicChunkMap;
}
declare type cheerio = ReturnType<typeof load>;
export declare type IHandler = ($: cheerio, args: IArgs) => cheerio;
export interface IPolyfill {
    host?: string;
}
declare type IContextFunc = () => object;
export interface IConfig {
    /** prefix path for `filename` and `manifest`, if both in the same directory */
    root?: string;
    /** ssr manifest, default: `${root}/ssr-client-mainifest.json` */
    manifest?: string;
    /** umi ssr server file, default: `${root}/umi.server.js` */
    filename?: string;
    /** default false */
    polyfill?: boolean | IPolyfill;
    /** use renderToStaticMarkup  */
    staticMarkup?: boolean;
    /** replace the default ReactDOMServer.renderToString */
    customRender?: (args: IRenderArgs) => Promise<string>;
    /** handler function for user to modify render html accounding cheerio */
    postProcessHtml?: IHandler | IHandler[];
    /** is dev env, default NODE_ENV=development */
    dev?: boolean;
    /** TODO: serverless */
    serverless?: boolean;
}
export interface IRenderOpts extends Pick<IConfig, 'polyfill'> {
    /** mock global object like { g_lang: 'zh-CN' } => global.window.g_lang / global.g_lang  */
    runInMockContext?: object | IContextFunc;
}
export interface IRenderArgs {
    htmlElement: React.ReactNode;
    rootContainer: React.ReactNode;
    matchPath: string;
    g_initialData: any;
    chunkMap?: IDynamicChunkMap;
}
export interface IContext {
    req: {
        url: string;
    };
}
export interface IResult {
    ssrHtml: string;
    matchPath: string;
    chunkMap?: IDynamicChunkMap;
}
export declare type IServer = (config: IConfig) => (ctx: IContext, renderOpts?: IRenderOpts) => Promise<IResult>;
declare const server: IServer;
export default server;
